goog.require('wpt.logging');goog.provide('wpt.chromeDebugger');((function() {  // namespacevar g_instance = {};/** * Construct an object that connectes to the Chrome debugger. * * @constructor * @param {?number} tabId The id of the tab being used to load the page *                       under test.  See that chrome.tabs.* docs to *                       understand what methods give and use this id. * @param {Object} chromeApi Object which contains the chrome extension *                           API methods.  The real one is window.chrome *                           in an extension.  Tests may pass in a mock *                           object. */wpt.chromeDebugger.Init = function(tabId, chromeApi) {	try {		g_instance.tabId_ = tabId;		g_instance.chromeApi_ = chromeApi;		if (g_instance.chromeApi_['debugger']) {				var version = "1.0";				g_instance.chromeApi_.debugger.attach({tabId:g_instance.tabId_}, version, wpt.chromeDebugger.OnAttachDebugger);		} else if (g_instance.chromeApi_.experimental['debugger']) {			// deal with the different function signatures for different chrome versions			try {				g_instance.chromeApi_.experimental.debugger.attach(g_instance.tabId_, wpt.chromeDebugger.OnAttachOld);			} catch (err) {				var version = "0.1";				g_instance.chromeApi_.experimental.debugger.attach({tabId:g_instance.tabId_}, version, wpt.chromeDebugger.OnAttachExperimental);			}		}  } catch (err) {    wpt.LOG.warning('Error initializing debugger interfaces: ' + err);  }};/** * Actual message callback */wpt.chromeDebugger.OnMessage = function(tabId, message, params) {	// Network events	if (message === "Network.requestWillBeSent") {		if (params.request.url.indexOf('http') == 0) {			var detail = {};			detail.url = params.request.url;			detail.initiator = params.initiator;			detail.startTime = params.timestamp;			g_instance.requests[params.requestId] = detail;		}	} else if (message === "Network.dataReceived") {		if (g_instance.requests[params.requestId] !== undefined && 				g_instance.requests[params.requestId]['firstByteTime'] === undefined) {			g_instance.requests[params.requestId].firstByteTime = params.timestamp;		}	} else if (message === "Network.responseReceived") {		if (!params.response.fromDiskCache && 				g_instance.requests[params.requestId] !== undefined) {			request = g_instance.requests[params.requestId];			request.endTime = params.timestamp;			request.response = params.response;			wpt.chromeDebugger.sendRequestDetails(request);		}	}		// console events	else if (message === "Console.messageAdded") {		wpt.chromeDebugger.sendEvent('console_log', JSON.stringify(params.message));	}		// Timeline	else if (message === "Timeline.eventRecorded") {		wpt.chromeDebugger.sendEvent('timeline', JSON.stringify(params.record));	}}/** * Attached using the 1.0 released interface */wpt.chromeDebugger.OnAttachDebugger = function(){	wpt.LOG.info('attached to debugger extension interface');	g_instance.requests = {};		// attach the event listener	g_instance.chromeApi_.debugger.onEvent.addListener(wpt.chromeDebugger.OnMessage);		// start the different interfaces we are interested in monitoring	g_instance.chromeApi_.debugger.sendCommand({tabId:g_instance.tabId_}, "Network.enable");	g_instance.chromeApi_.debugger.sendCommand({tabId:g_instance.tabId_}, "Console.enable");	// the timeline is pretty resource intensive - TODO, make this optional	//g_instance.chromeApi_.debugger.sendCommand({tabId:g_instance.tabId_}, "Timeline.start");}			/** * Attached using the old experimental interface */wpt.chromeDebugger.OnAttachOld = function(){	wpt.LOG.info('attached to debugger old experimental extension interface');	g_instance.requests = {};		// attach the event listener	g_instance.chromeApi_.experimental.debugger.onEvent.addListener(wpt.chromeDebugger.OnMessage);		// start the different interfaces we are interested in monitoring	g_instance.chromeApi_.experimental.debugger.sendRequest(g_instance.tabId_, "Network.enable");	g_instance.chromeApi_.experimental.debugger.sendRequest(g_instance.tabId_, "Console.enable");	// the timeline is pretty resource intensive - TODO, make this optional	//g_instance.chromeApi_.experimental.debugger.sendRequest(g_instance.tabId_, "Timeline.start");}/** * Attached using the new experimental interface */wpt.chromeDebugger.OnAttachExperimental = function(){	wpt.LOG.info('attached to debugger experimental extension interface');	g_instance.requests = {};		// attach the event listener	g_instance.chromeApi_.experimental.debugger.onEvent.addListener(wpt.chromeDebugger.OnMessage);		// start the different interfaces we are interested in monitoring	g_instance.chromeApi_.experimental.debugger.sendCommand({tabId:g_instance.tabId_}, "Network.enable");	g_instance.chromeApi_.experimental.debugger.sendCommand({tabId:g_instance.tabId_}, "Console.enable");	// the timeline is pretty resource intensive - TODO, make this optional	//g_instance.chromeApi_.experimental.debugger.sendCommand({tabId:g_instance.tabId_}, "Timeline.start");}			/** * Process and send the data for a single request * to the hook for processing * @param {object} request Request data */wpt.chromeDebugger.sendRequestDetails = function (request) {	var eventData = 'browser=chrome\n';	eventData += 'url=' + request.url + '\n';	if (request['startTime'] !== undefined)		eventData += 'startTime=' + request.startTime + '\n';	if (request['firstByteTime'] !== undefined)		eventData += 'firstByteTime=' + request.firstByteTime + '\n';	if (request['endTime'] !== undefined)		eventData += 'endTime=' + request.endTime + '\n';	if (request['initiator'] !== undefined 			&& request.initiator['type'] !== undefined) {		eventData += 'initiatorType=' + request.initiator.type + '\n';		if (request.initiator.type == 'parser') {			if (request.initiator['url'] !== undefined)				eventData += 'initiatorUrl=' + request.initiator.url + '\n';			if (request.initiator['lineNumber'] !== undefined)				eventData += 'initiatorLineNumber=' + request.initiator.lineNumber + '\n';		} else if (request.initiator.type == 'script' && 							request.initiator['stackTrace'] && 							request.initiator.stackTrace[0]) {			if (request.initiator.stackTrace[0]['url'] !== undefined)				eventData += 'initiatorUrl=' + request.initiator.stackTrace[0].url + '\n';			if (request.initiator.stackTrace[0]['lineNumber'] !== undefined)				eventData += 'initiatorLineNumber=' + request.initiator.stackTrace[0].lineNumber + '\n';			if (request.initiator.stackTrace[0]['columnNumber'] !== undefined)				eventData += 'initiatorColumnNumber=' + request.initiator.stackTrace[0].columnNumber + '\n';			if (request.initiator.stackTrace[0]['functionName'] !== undefined)				eventData += 'initiatorFunctionName=' + request.initiator.stackTrace[0].functionName + '\n';		}	}	if (request['response'] !== undefined) {		if (request.response['connectionId'] !== undefined)				eventData += 'connectionId=' + request.response.connectionId + '\n';		if (request.response['timing'] !== undefined) {			eventData += 'timing.dnsStart=' + request.response.timing.dnsStart + '\n';			eventData += 'timing.dnsEnd=' + request.response.timing.dnsEnd + '\n';			eventData += 'timing.connectStart=' + request.response.timing.connectStart + '\n';			eventData += 'timing.connectEnd=' + request.response.timing.connectEnd + '\n';			eventData += 'timing.sslStart=' + request.response.timing.sslStart + '\n';			eventData += 'timing.sslEnd=' + request.response.timing.sslEnd + '\n';		}				// the end of the data is ini-file style for multi-line values		eventData += '\n';		if (request.response['requestHeadersText'] !== undefined)			eventData += '[Request Headers]\n' + request.response.requestHeadersText + '\n'		if (request.response['headersText'] !== undefined)			eventData += '[Response Headers]\n' + request.response.headersText + '\n'	}  wpt.chromeDebugger.sendEvent('request_data', eventData);}/** * Send an event to the c++ code * @param {string} event event string * @param {string} data event data (post body) */wpt.chromeDebugger.sendEvent = function (event, data) {  try {    var xhr = new XMLHttpRequest();    xhr.open('POST', 'http://127.0.0.1:8888/event/' + event, true);		xhr.send(data);  } catch (err) {    wpt.LOG.warning('Error sending request data XHR: ' + err);  }}})());  // namespace