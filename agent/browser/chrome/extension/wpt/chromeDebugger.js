goog.require('wpt.logging');goog.provide('wpt.chromeDebugger');((function() {  // namespace/** * Construct an object that connectes to the Chrome debugger. * * @constructor * @param {?number} tabId The id of the tab being used to load the page *                       under test.  See that chrome.tabs.* docs to *                       understand what methods give and use this id. * @param {Object} chromeApi Object which contains the chrome extension *                           API methods.  The real one is window.chrome *                           in an extension.  Tests may pass in a mock *                           object. */wpt.chromeDebugger.Init = function(tabId, chromeApi) {	var self = this;	this.tabId_ = tabId;	this.chromeApi_ = chromeApi;	if (this.chromeApi_.experimental['debugger']) {		this.chromeApi_.experimental.debugger.attach(this.tabId_, function(){			wpt.LOG.info('attached to debugger extension interface');			self.requests = {};						// attach the event listener			self.chromeApi_.experimental.debugger.onEvent.addListener(function(tabId, message, params) {				// Network events				if (message === "Network.requestWillBeSent") {					if (params.request.url.indexOf('http') == 0) {						var detail = {};						detail.url = params.request.url;						detail.initiator = params.initiator;						detail.startTime = params.timestamp;						self.requests[params.requestId] = detail;					}				} else if (message === "Network.dataReceived") {					if (self.requests[params.requestId] !== undefined && 							self.requests[params.requestId]['firstByteTime'] === undefined) {						self.requests[params.requestId].firstByteTime = params.timestamp;					}				} else if (message === "Network.responseReceived") {					if (!params.response.fromDiskCache && 							self.requests[params.requestId] !== undefined) {						request = self.requests[params.requestId];						request.endTime = params.timestamp;						request.response = params.response;						wpt.chromeDebugger.sendRequestDetails(request);					}				}								// console events				else if (message === "Console.messageAdded") {					wpt.chromeDebugger.sendEvent('console_log', JSON.stringify(params.message));				}								// Timeline				else if (message === "Timeline.eventRecorded") {					wpt.chromeDebugger.sendEvent('timeline', JSON.stringify(params.record));				}			});						// start the different interfaces we are interested in monitoring			self.chromeApi_.experimental.debugger.sendRequest(self.tabId_, "Network.enable");			self.chromeApi_.experimental.debugger.sendRequest(self.tabId_, "Console.enable");			// the timeline is pretty resource intensive - TODO, make this optional			//self.chromeApi_.experimental.debugger.sendRequest(self.tabId_, "Timeline.start");		});	}};/** * Process and send the data for a single request * to the hook for processing * @param {object} request Request data */wpt.chromeDebugger.sendRequestDetails = function (request) {	var eventData = 'browser=chrome\n';	eventData += 'url=' + request.url + '\n';	if (request['startTime'] !== undefined)		eventData += 'startTime=' + request.startTime + '\n';	if (request['firstByteTime'] !== undefined)		eventData += 'firstByteTime=' + request.firstByteTime + '\n';	if (request['endTime'] !== undefined)		eventData += 'endTime=' + request.endTime + '\n';	if (request['initiator'] !== undefined 			&& request.initiator['type'] !== undefined) {		eventData += 'initiatorType=' + request.initiator.type + '\n';		if (request.initiator.type == 'parser') {			if (request.initiator['url'] !== undefined)				eventData += 'initiatorUrl=' + request.initiator.url + '\n';			if (request.initiator['lineNumber'] !== undefined)				eventData += 'initiatorLineNumber=' + request.initiator.lineNumber + '\n';		} else if (request.initiator.type == 'script' && 							request.initiator['stackTrace'] && 							request.initiator.stackTrace[0]) {			if (request.initiator.stackTrace[0]['url'] !== undefined)				eventData += 'initiatorUrl=' + request.initiator.stackTrace[0].url + '\n';			if (request.initiator.stackTrace[0]['lineNumber'] !== undefined)				eventData += 'initiatorLineNumber=' + request.initiator.stackTrace[0].lineNumber + '\n';			if (request.initiator.stackTrace[0]['columnNumber'] !== undefined)				eventData += 'initiatorColumnNumber=' + request.initiator.stackTrace[0].columnNumber + '\n';			if (request.initiator.stackTrace[0]['functionName'] !== undefined)				eventData += 'initiatorFunctionName=' + request.initiator.stackTrace[0].functionName + '\n';		}	}	if (request['response'] !== undefined) {		if (request.response['connectionId'] !== undefined)				eventData += 'connectionId=' + request.response.connectionId + '\n';		if (request.response['timing'] !== undefined) {			eventData += 'timing.dnsStart=' + request.response.timing.dnsStart + '\n';			eventData += 'timing.dnsEnd=' + request.response.timing.dnsEnd + '\n';			eventData += 'timing.connectStart=' + request.response.timing.connectStart + '\n';			eventData += 'timing.connectEnd=' + request.response.timing.connectEnd + '\n';			eventData += 'timing.sslStart=' + request.response.timing.sslStart + '\n';			eventData += 'timing.sslEnd=' + request.response.timing.sslEnd + '\n';		}				// the end of the data is ini-file style for multi-line values		eventData += '\n';		if (request.response['requestHeadersText'] !== undefined)			eventData += '[Request Headers]\n' + request.response.requestHeadersText + '\n'		if (request.response['headersText'] !== undefined)			eventData += '[Response Headers]\n' + request.response.headersText + '\n'	}  wpt.chromeDebugger.sendEvent('request_data', eventData);}/** * Send an event to the c++ code * @param {string} event event string * @param {string} data event data (post body) */wpt.chromeDebugger.sendEvent = function (event, data) {  try {    var xhr = new XMLHttpRequest();    xhr.open('POST', 'http://127.0.0.1:8888/event/' + event, true);		xhr.send(data);  } catch (err) {    wpt.LOG.warning('Error sending request data XHR: ' + err);  }}})());  // namespace